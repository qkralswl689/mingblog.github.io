---
layout: post
title: "1과목.소프트웨 설계_03장.어플리케이션 설계"
date: 2021-01-17
category : [정보처리기사]
comments: true
---
# 1과목.소프트웨어 설계
## - 3장. 어플리케이션 설계

### * 소프트웨어 아키텍처

```
* 아케텍처 : 기본구조 -> 소프트웨어의 "베이스" => 품질유지 및 개발의 원칙,지침의 역할
         => EX) 동일한 아키텍처 -> 기본 구조가 같은 여러 형태의 결과물

   - 아키텍처 설계 원리 : 모듈화(부품화)를 기준으로 설계 => 유지관리가 용이 하기때문
      - 모듈화의 3가지 원리
        1. 추상화 : 각 요소들의 공통적인 부분을 포괄하는 것
                  EX) 로그인/회원가입/아이디 찾기/비밀번호 찾기 기능 => 인증기능 으로  묶어서 생각
            특징 - 구체화 하기 위해서 진행하는 단계
                 - 복잡한 문제를 최소비용으로 해결 할 수 있다.
                 - 구조 파악에 용이
            단계 : 과정 - 데이터 - 제어 로 유형을 구분
              1. 과정 : 흐름
              2. 구조 : 데이터
              3. 제어 : 이벤트     

        2. 단계적 분해 : 세부적인 분류를 다시하는것
                      => 추상화를 반복 할수록 구체적인 분해가 가능하다 => 하향식 구체화
                      EX) 로그인 기능 만들기 -> 알고리즘 구체화 -> 자료구조 구체화
        3. 정보은닉 : 각각의 모듈이 서로 접근할 수 없도록 차단하는 과정
                    => 별도의 인터페이스를 사용해서만 접근을 허락한다 -> 각각의 모듈의 유지보수에 용이하다.

   - 아키텍처 품질 속성
        - 시스템 품질 : 성능 및 보완 관련 (성능,보안,가용성,기능성,사용성)
        - 비즈니스 품질 : 비용과 자원 관련 (시장 적시성,비용과 혜택,시스템 수명)
        - 아키텍처 품질 : 결함과 주고 관련 (무결성,정확성,완결성,구축가능성)

   - 아키텍처 설계 과정 : 목표 설정 - 시스템 타입 - 아키텍처 패턴 - 시스템 구체화 - 검토
                      1. 목표설정 : 개발 방향, 우선순위 설정 등
                      2. 시스템 타입 : 시스템 타입 결정
                                    - 대화형 : 일반적인 어플리케이션
                                    - 이벤트형 : 외부신호(센서 OR 신호)에 반응하여 작동
                                    - 변환형 : 데이터 변환(데이터를 다른 형태로 바꾼다)
                                    - 객체 영속형 : 데이터베이스 시스템
                      3. 아키텍처 패턴 : 아키텍처를 설계할 때 참고할만한 좋은 공식
                      4. 시스템 구체화 : 서브시스템들의인터페이스와 인터랙션 구체화
                      5. 검토
   ★ 아키텍쳐 = 모듈 => 모듈은 아키텍처 패턴을 활용해서 제작한다.
```
### * 아키텍처 패턴
```
* 아키텍처 패턴 : - 문제해결의 윤곽 제시
                 - 원칙과 지침역할
                 - 아키텍처 스타일,표준 아키텍처 도 같은말이다
        - 장점 : 시간 단축,품질 향상,검증 편리,소통 원활,이해 용이,예측 가능 등
        - 종류 : 1. 레이어(계층) 패턴 : 시스템을 계층구조(layer)로 쌓아둔 패턴
                    => 각각의 상위,하위 레이어끼리만 상호작용을 한다 : 특정 레이어만 유지보수하여 시스템을 개선할 수 있다.
                 2. 클라이언트 - 서버 패턴 : 서버 : 자원을 관리,제공 / 클라이언트 : 자원을 요청,사용
                               => 서버와 클라리언트는 서로 독립적인 기능 존재
                 3. 파이프 - 필터 패턴 : 파이프 : 단순한 라인 / 필터 : 파이프로 넘어온 데이터를 처리,캡슐화(정보은닉)
                                     => 데이터의 흐름 : 스트림 => 스트림의 각 단계를 파이프와 필터로 연결  
                                      - 장점 : 재사용성과 확장성이 좋다 => 다양한 파이프라인을 생성할 수 있다.
                                               데이터 변환, 버퍼링, 동기화 등의 작업에 유리하다.
                 4. 모델 - 뷰 - 컨트롤러 패턴 : 컴포넌트(모듈)들을 모델 - 뷰 - 컨트롤러로 구성한 것
                                           => 모델 : 핵심기능과 데이터 보관
                                              컨트롤러 : 입력 처리
                                              뷰 : 처리된 정보를 표시 => 여러 형태의 뷰를 생성할 수 있다.
                                            * 일반적인 어플리케이션에 적합
                 5. 마스터 - 슬레이브 패턴 : 마스터 컴포넌트가 지시한 일을 여러 슬레이브 컴포넌트가 병렬처리하여 결과를 취합한다.
                                        => 도중에 몇개의 슬레이브가 고장나도 업무처리엔 문제가 없다.
                 6. 브로커 패턴 : 클라이언트의 요청을 중간에서 브로커가 적절한 서버로 연결해주는 형식    
                              => 서버가 여러개 존재한다 -> 분산환경 시스템
                 7. 피어 - 투 - 피어 패턴 : 서버와 클라이언트가 서로 역할을 바꿀 수 있는 형태
                                        => P2P : 2가지일을 병렬로 수행하는 멀티스레딩이 특징
                 8. 이벤트 - 버스 패턴 : 특정 이벤트를 발행하면 해당 채널(버스)를 구독하고 있는 리스너들이 이벤트를 받아 처리하는 형식
                 9. 블랙보드 패턴 : 많은 컴포넌트들이 공유데이터를 관리하는 블랙보드에 접근하여 원하는 데이터를 찾는 형식
                                => 음성인식,차량식별,신호해석 등의 기술에서 사용
```
### * 객체지향
```
 * 기초지식
    - 절차(구조적) 지향 : 프로그램을 하나의 큰 절차(순서)로 구성 , 함수(모든 데이터타입의 집합체)로 제어해서 결과를 내는 것
                         프로그램 자체를 한 덩어리로 설계하기 때문에 원하지 않는 접근을 차단할 방법이 없다

          - 데이터 : 입력된 값 그대로
               =>  상수(변하지 않는 값) / 변수(상수에 의미를 부여한것) / 배열(같은종류의 변수를 여러개 모은것) / 구조체 (서로 다른종류의 데이터를 모으는것)
          - 정보 : 별도의 의미를 부여하는 데이터
          - 기능 : 실행문(명령을 실행하는 문) / 조건제어,분기문(조건에 따라 실행을 하게 만들어 주는것) / 반복문,루프문(같은문장을 여러번 반복) / (원할때 만 여러번 반복)
          - 클래스 : 데이터와 그에 관련덴 기능들을 묶어서 캡슐화
                 => 정보은닉 가능, 재사용 및 확장(유지보수) 용이
              - 클래스 - 인스턴스 : 클래스를 재사용 하기 위해 복제한 결과물(인스턴스) => 객체 :인스턴스를 통칭
                                => 복제된 객체들은 같은 클래스의 구조를 가지지만 내용을 서로 다르게 가질 수 있다.
              - 클래스 - 상속 : 상속을 받은 하위클래스는 상위클래스의 모든 요소에 더해 자신의 요소까지 전부 사용이 가능한 인스턴스를 생성할 수 있다 => 상속을 통해 재사용 + 확장의 개념까지 가질 수 있다.   
★ 객체지향에서는 여러가지 객체들이 서로 메세지를 보내면서 기능 및 데이터사용을 요청하고 그 결과를 돌려주면서 프로그램이 진행된다
** 객제치향의 최종 목표 **
      - 다형성 : 클래스는 상속을 통해 여러가지 기능을 확장할 수 있다,거기서 생성된 인스턴스 역시 많은 기능을 가지고 있고, 이 인스턴스에 기능의 제한을 걸어 특정 기능만 수행할 수 있다면 "일일히 그 기능만 수행하는 객체들을 따로 생성할 필요없이 하나의 통합 객체로 여러가지 일을 수행할 수 있게 된다"
```
### * 모듈
```
 * 모듈 = 부품 => 모듈화를 통해 분리된 기능들
   - 모듈 : 서브루틴이나 서브시스템 등 다양한 용어를 함께 사용한다.
            재사용,유지보수가 용이하다 => 모듈들이 서로 영향을 주지 않게끔 독립적이다 => 독립성이 강하다 = 품질이 좋다
            - 독립성의 정도를 판단하는 기준 : 결합도,응집도
              - 결합도 : 상호의존의 정도 => 결합도가 약해야 품질이 상승한다.
                     => 자료 : 데이터로 구성 -> 모듈간의 인터페이스가 데이터로만 구성되어 있다 => 결합도가 가장 약하다
                        스탬프 : 인터페이스가 가로구조로 구성되어 있다 (다른 모듈이 영향을 받음)
                        제어 : 모듈의 흐름제어를 다른 모듈에서 건드릴 수 있다
                        외부 : 외부에 있는 다른 모듈의 데이터를 건드린다
                        공유 : 공유(공통) 데이터를 여러 모듈들이 사용하는 형태
                        내용 : 같은공간에 있다 -> 내부기능과 데이터를 직접 참조할 수 있는 상태 => 결합도가 가장 강하다
             - 응집도 : 정보은닉의 개념을 좀 더 확장시킨 개념 => 내부요소들 끼리도 관련성을 판단하여 서로 기능간섭이 없게끔 하는 것 => 응집도가 강할수록 품질이 상승한다
                    => 기능 : 단일기능만 연걸되어 있다 => 응집도가 가장 강하다
                       순차 : A모듈의 출력이 B모듈에 입력이 되는 형태 => 두가지 기능이 연결된다
                       통신 : 입출력은 동일하지만 서로 다른기능을 수행하는 요소들이 모인 형태
                       절차 : "다수의 기능"이 순차적으로 진행되는 형태
                       시간 : 특정시간에 처리할 기능을 모아둔 것
                       논리 : 유사한 기능을 모아둔 것
                       우연 : 관련이 없는 기능들을 모아둔 형태
            - 팬 - 인 , 팬 - 아웃 (인 : 제어신호가 들어온다 / 아웃 : 제어신호가 나간다)
               : 팬 - 인 : 해당 모듈로 들어오는 제어신호
                 팬 - 아웃 : 해당 모듈에서 나가는 제어신호
            * 시스템 복잡도를 최소화하기 위해서는 인은 높게,아웃은 낮게 설계해야 한다

   - 공통모듈 : 공통적으로 사용하는 모듈
            =>    기법     |    설명
              -------------------------
                  정확성   |   필요성
              -------------------------
                  명확성   |   비중의적(한가지 의미로 해석되도록)
              -------------------------
                  완전성   |   필요한 모든것
              -------------------------
                  일관성   |   충돌방지
              -------------------------
                  추적성   |  출처,관계파악

  ★ 효과적인 모듈 설계 방안
    - 결합도(낮게) + 응집도(높게) = 독립성이 높아진다 => 재사용 및 유지보수가 가능해진다.
    - 복잡도(낮게) + 중복성(낮게) + 입출력(하나) = 품질이 높아진다

```
### * 코드/디자인 패턴
```
 * 코드 : 일정한 규칙에 따라 만들어진 "기호" => 식변,분류,배열 의 기능을 가지게 된다
   - 종류 : 1. 순차 : 숫자가 차례대로 입력되어 있는 일련번호와 같다 => 혼자쓰이지 않고 다른 개념들에 더해서 사용한다
            2. 블록 : 구역을 구분한뒤 순차코드를 붙힌다
            3. 10진 : 항목들을 10진분할(10개로 나누는것) => 이 과정을 필요할 때까지 반복해서 코드를 부여하는 것
            4. 그룹분류 : 하이픈으로 구별하고 항목별로 일련번호를 부여한다 (10진분할과 비슷)
            5. 연상 : 코드만 봐도 어떤 제품인지 연상이 되는 형태
            6. 표의숫자 : 해당 제품의 수치 등을 코드에 사용한 것

* 디자인 : 서브 시스템에 대한 상세 구현에 대한 공식
  - 특징 : 패턴을 새로 만들기 보다 있는것을 활용하는것이 좋다
           만약 패턴을 변형할 경우 기존의 다른 패턴의형식으로 변하는 경향이 있다
           생성5개 / 구조7개 / 행위11개 로 구성된다
           - 생성패턴 : 객체 생성에 대한 패턴 => 캡슐화,유현성을 목표로한다
                     - 추상팩토리(Abstract Factory) : 상위클래스의 객체 생성코드를 하위클래스가 상속받는다 => 상위클래스의 코드가 변경되면 상속중인 모든 하위클래스도 전부변경된다 -> 하위클래스에 의존하지 않는 형태
                     - 팩토리 메소드(Factory Method) : 객체생성코드를 하위클래스에서 구체화 하는것 => 상위클래스는 인터페이스만 제공한다 -> 각각의 클래스가 서로 다른 작업수행이 가능해진다
                     - 빌더(Builder) : 분리된 인스턴스를 조합해서 객체를 생성한다 => 생성과 표현을 분리한다 -> 같은 객체를 생성해도 다른 결과를 도출할 수 있는 형태
                     - 프로토타입(Prototype) : 원본을 복제하는 형태로 객체를 생성한다 => 비용(자원)이 저렴하다
                     - 싱글톤(Singleton) : 클래스 내 생성되는 인스턴스가 하나만 필요할 때 사용한다 => 생성된 인스턴스는 동시참조가 불가능하다
           - 구조패턴 : 구조가 복잡한 시스템 개발에 도움을준다
                     - 어댑터(Adapter) : 클래스간에 서로 일치하지 않는 인터페이스를 변환해준다
                     - 브릿지(Bridge) : 기능을 정의하는 주상층과 구체화하는 구현층을 서로 분리하여 서로 독립적인 확장이 가능하도록 구성한다
                     - 컴포지트(Composite) : 단일객체와 복합객체를 구분없이 하나의 묶음으로 다루기 위해 트리구조로 구성한다
                     - 데코레이터(Decorator) : 클래스에 기능을 추가하기 위해 다른객체를 덧붙이는 형태
                     - 퍼싸드(Facade) : 다수의 서브클래스들의 통합 인터페이스를 제공할 수 있는 "wrapper객체"를 통해 서브 클래스들을 간편하게 이용하게 할수 있는 패턴
                     - 플라이웨이트(Flyweight) : 다수의 유사객체 생성이 필요할 때 메모리 절약을 위해 매번 객체를 생성하지 않고 최대한 공유해서 사용하는 형태
                     - 프록시(Proxy) : 접근이 어려운 객체에 접근할 수 있도록 인터페이스 역할을 한다
           - 행위패턴 : 상호작용이나 책임 분배에 대한 부분을 정의하고 결합도를 최소화 하는것이 목표
                     - 책임연쇄(Chain of Responsibility) : 둘 이상의 객체가 고리처럼 연결되어 책임이 차례로 넘어간다
                     - 커맨드(Command) : 요청에 필요한 명령어를 객체화하여 로그에 기록하는 형식
                     - 인터프리터(Interpreter) : 문법표현을 정의한다 => 맞춤법 검사
                     - 반복자(Iterator) : 접근이 잦은 객체는 동일한 인터페이스를 사용하도록 한다 => 순차적 접근이 가능
                     - 중재자(Mediator) : 수많은 객체들이 있다면 필연적으로 상호작용이 복잡할 수 밖에 없다 => 상호작용을 캡슐화 => 결합도를 낮추기위해 사용
                     - 메멘토(Memento) : 특정시점의상태를 객체화, 필요에 따라 해당위치로 돌린다
                     - 옵저버(Observer) : 객체상태가 변하면 상속중인 다른 객체들에게 전달하는 형태
                     - 상태(State) : 이벤트를 객체 상태에 따라 다르게 처리해야 할 때 사용
                     - 전략(Strategy) : 동일계열의 알고리즘을 개별적으로 객체화하여 상호 교환한다 => 독립적 사용가능 -> 서로 영향없이 변경가능
                     - 템플릿 메소드(Template Method) : 상위클래스에서 인터페이스 정의, 하위클래스에서 인터페이스 구체화 => 코드의 유지보수가 쉬워진다
                     - 방문자(Vistor) : 처리기능을 별도의 클래스로 분리하는 패턴 => 데이터구조와 기능을 분리하는 형태





```

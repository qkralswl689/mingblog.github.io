---
layout: post
title: 'Thymeleaf 소개'
date: 2021-06-08
category: [Thymeleaf]
comments: true
---

1 Thymeleaf 소개

1.1 Thymeleaf는 무엇입니까?

Thymeleaf는 HTML, XML, JavaScript, CSS 및 일반 텍스트를 처리 할 수있는 웹 및 독립 실행 형 환경을위한 최신 서버 측 Java 템플릿 엔진입니다.

Thymeleaf의 주요 목표 : 우아하고 유지 관리가 쉬운 템플릿 생성 방법을 제공하는 것입니다.
를 달성하기 위해 Natural Templates 개념을 기반으로 설계 프로토 타입으로 사용되는 템플릿에 영향을주지 않는 방식으로 템플릿 파일에 로직을 삽입합니다.
이를 통해 디자인 커뮤니케이션이 향상되고 디자인 팀과 개발 팀 간의 격차가 해소됩니다.

=> JSTL(JSP) 는 java코드가 무조건 들어가야한다 but Thymeleaf는 더 간결하다 -> 배우기 쉽고 비전공자(디자이너등)도 사용하기 쉽다

또한 Thymeleaf는 웹 표준 (특히 HTML5) 을 염두에두고 처음부터 설계되어 필요한 경우 완전한 유효성 검사 템플릿을 만들 수 있습니다.

1.2 Thymeleaf는 어떤 종류의 템플릿을 처리 할 수 ​​있습니까?
바로 사용할 수있는 Thymeleaf를 사용하면 6 가지 종류의 템플릿을 처리 할 수 ​​있으며 각 템플릿을 템플릿 모드 라고합니다 .

HTML
XML
TEXT
JAVASCRIPT
CSS
RAW

두 가지 마크 업 템플릿 모드 ( HTML및 XML), 세 가지 텍스트 템플릿 모드 ( TEXT, JAVASCRIPT및 CSS) 및 작동 하지 않는 템플릿 모드 ( RAW)가 있습니다.

HTML템플릿 모드는 HTML5, HTML 4과 XHTML을 포함하여, HTML 입력의 모든 종류의 수 있습니다. 유효성 검사 또는 올바른 형식 검사는 수행되지 않으며 템플릿 코드 / 구조는 출력에서 ​​가능한 한 최대한 존중됩니다.

XML템플릿 모드는 XML 입력을 허용합니다. 이 경우 코드는 닫히지 않은 태그, 인용되지 않은 속성 등의 올바른 형식이어야하며 올바른 형식 위반이 발견되면 파서가 예외를 throw합니다. 더합니다 검증 (A DTD 또는 XML 스키마에 대한)이 수행되지 않습니다.

TEXT템플릿 모드가 아닌 마크 업 자연의 템플릿을위한 특별한 구문을 사용할 수 있습니다. 이러한 템플릿의 예로는 텍스트 이메일 또는 템플릿 문서가 있습니다. HTML 또는 XML 템플릿은으로도 처리 될 수 있습니다 TEXT.이 경우 태그는 마크 업으로 구문 분석되지 않으며 모든 태그, DOCTYPE, 주석 등은 단순한 텍스트로 처리됩니다.

JAVASCRIPT템플릿 모드는 Thymeleaf 응용 프로그램에서 자바 스크립트 파일의 처리를하실 수 있습니다. 즉, HTML 파일에서 수행 할 수있는 것과 동일한 방식으로 JavaScript 파일 내에서 모델 데이터를 사용할 수 있지만 특수 이스케이프 또는 자연스러운 스크립팅 과 같은 JavaScript 관련 통합을 사용할 수 있습니다 . JAVASCRIPT템플릿 모드는 고려 텍스트 모드 때문에 같은 특수 구문을 사용 TEXT템플릿 모드.

CSS템플릿 모드는 Thymeleaf 응용 프로그램에 관련된 CSS 파일의 처리를하실 수 있습니다. 받는 유사 JAVASCRIPT모드에서 CSS템플릿 모드도있다 텍스트 모드와에서 특수 처리 구문을 사용 TEXT템플릿 모드.

RAW템플릿 모드는 단순히 모두에서 템플릿을 처리하지 않습니다. 처리중인 템플릿에 수정되지 않은 리소스 (파일, URL 응답 등)를 삽입하는 데 사용됩니다. 예를 들어, HTML 형식의 제어되지 않은 외부 리소스는 애플리케이션 템플릿에 포함될 수 있으며 이러한 리소스에 포함될 수있는 Thymeleaf 코드가 실행되지 않을 것임을 안전하게 알 수 있습니다.

1.3 방언 : 표준 방언 => Dialects: Standard Dialects 라는 라이브러리를 사용한다

Thymeleaf는 템플릿이 세부적으로 처리되는 방식을 정의하고 사용자 지정할 수 있는 매우 확장 가능한 템플릿 엔진 (사실은 템플릿 엔진 프레임 워크 라고도 함 )입니다.

마크 업 아티팩트 (태그, 일부 텍스트, 주석 또는 템플릿이 마크 업이 아닌 경우 단순한 자리 표시 자)에 일부 로직을 적용하는 객체를 프로세서 라고하며 이러한 프로세서 세트와 추가 아티팩트는 무엇입니까? 방언이 정상적으로 이루어진다. 기본적으로 Thymeleaf의 핵심 라이브러리는 Standard Dialect 라는 방언을 제공하며 대부분의 사용자에게 충분합니다.

방언은 실제로 프로세서가없고 완전히 다른 종류의 아티팩트로 구성 될 수 있지만 프로세서는 확실히 가장 일반적인 사용 사례입니다.

이 튜토리얼은 표준 언어에 대해 다룹니다 . 다음 페이지에서 배우게 될 모든 속성 및 구문 기능은 명시 적으로 언급되지 않은 경우에도이 방언으로 정의됩니다.

물론 라이브러리의 고급 기능을 활용하면서 자체 처리 논리를 정의하려는 경우 사용자는 자신의 방언을 만들 수 있습니다 (표준 방언도 확장). Thymeleaf는 한 번에 여러 방언을 사용하도록 구성 할 수도 있습니다.

공식 thymeleaf-spring3 및 thymeleaf-spring4 통합 패키지는 모두 "SpringStandard Dialect"라는 방언을 정의합니다.이 방언은 표준 방언과 거의 동일하지만 Spring Framework의 일부 기능을 더 잘 사용하기 위해 약간의 조정이 있습니다 (예 : , OGNL 대신 Spring Expression Language 또는 SpringEL을 사용하여). 따라서 Spring MVC 사용자라면 여기서 배우는 거의 모든 것이 Spring 애플리케이션에서 사용되므로 시간을 낭비하지 않을 것입니다.

Standard Dialect의 대부분의 프로세서는 속성 프로세서 입니다. 이를 통해 브라우저는 단순히 추가 속성을 무시하기 때문에 처리되기 전에도 HTML 템플릿 파일을 올바르게 표시 할 수 있습니다. 예를 들어, 태그 라이브러리를 사용하는 JSP에는 다음과 같은 브라우저에서 직접 표시 할 수없는 코드 조각이 포함될 수 있습니다.

\*\*\*\*JSP 는 뭔가 선언 해줘야 한다
<form:inputText name="userName" value="${user.name}" />
… Thymeleaf Standard Dialect를 사용하면 다음과 같은 기능을 사용할 수 있습니다.

\*\* th:가없으면 앞에꺼 사용한다
<input type="text" name="userName" value="James Carrot" th:value="${user.name}" />
이것은 브라우저에 의해 올바르게 표시 될뿐만 아니라 프로토 타입이 브라우저에서 정적으로 열릴 때 표시 될 값 속성 (이 경우 "James Carrot")을 (선택적으로) 지정할 수도 있습니다. ${user.name}템플릿을 처리하는 동안 평가 결과 값으로 대체됩니다 .

이렇게하면 디자이너와 개발자가 동일한 템플릿 파일에서 작업하고 정적 프로토 타입을 작업 템플릿 파일로 변환하는 데 필요한 노력을 줄일 수 있습니다. 이를 수행하는 기능은 Natural Templating 이라는 기능 입니다.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

2 Good Thymes 가상 식료품
여기에 표시된 예제와이 가이드의 향후 장에 대한 소스 코드는 Good Thymes Virtual Grocery GitHub 저장소 에서 찾을 수 있습니다 .

2.1 식료품 웹 사이트
Thymeleaf를 사용한 템플릿 처리와 관련된 개념을 더 잘 설명하기 위해이 자습서에서는 프로젝트의 웹 사이트에서 다운로드 할 수있는 데모 애플리케이션을 사용합니다.

이 애플리케이션은 가상의 가상 식료품 웹 사이트이며 Thymeleaf의 다양한 기능을 보여줄 수있는 많은 시나리오를 제공합니다.

: 시작하려면, 우리는 우리의 응용 프로그램에 대한 모델 개체의 간단한 설정이 필요 Products에 판매하고 Customers만들어를 Orders. 다음과 Comments같은 Products사항 도 관리 할 것입니다 .

예제 애플리케이션 모델
예제 애플리케이션 모델
우리의 애플리케이션은 또한 Service다음과 같은 메소드를 포함 하는 객체 로 구성된 매우 간단한 서비스 계층을 가질 것입니다.

public class ProductService {

    ...

    public List<Product> findAll() {
        return ProductRepository.getInstance().findAll();
    }

    public Product findById(Integer id) {
        return ProductRepository.getInstance().findById(id);
    }

}
웹 레이어에서 애플리케이션은 요청 URL에 따라 Thymeleaf 지원 명령에 실행을 위임하는 필터를 갖습니다.

private boolean process(HttpServletRequest request, HttpServletResponse response)
throws ServletException {

    try {

        // This prevents triggering engine executions for resource URLs
        if (request.getRequestURI().startsWith("/css") ||
                request.getRequestURI().startsWith("/images") ||
                request.getRequestURI().startsWith("/favicon")) {
            return false;
        }


        /*
         * Query controller/URL mapping and obtain the controller
         * that will process the request. If no controller is available,
         * return false and let other filters/servlets process the request.
         */
        IGTVGController controller = this.application.resolveControllerForRequest(request);
        if (controller == null) {
            return false;
        }

        /*
         * Obtain the TemplateEngine instance.
         */
        ITemplateEngine templateEngine = this.application.getTemplateEngine();

        /*
         * Write the response headers
         */
        response.setContentType("text/html;charset=UTF-8");
        response.setHeader("Pragma", "no-cache");
        response.setHeader("Cache-Control", "no-cache");
        response.setDateHeader("Expires", 0);

        /*
         * Execute the controller and process view template,
         * writing the results to the response writer.
         */
        controller.process(
                request, response, this.servletContext, templateEngine);

        return true;

    } catch (Exception e) {
        try {
            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        } catch (final IOException ignored) {
            // Just ignore this
        }
        throw new ServletException(e);
    }

}
이것이 우리의 IGTVGController인터페이스입니다.

public interface IGTVGController {

    public void process(
            HttpServletRequest request, HttpServletResponse response,
            ServletContext servletContext, ITemplateEngine templateEngine);

}
지금해야 할 일은 IGTVGController인터페이스의 구현을 생성 하고 서비스에서 데이터를 검색하고 ITemplateEngine개체를 사용하여 템플릿을 처리하는 것입니다.

결국 다음과 같이 보일 것입니다.

예제 애플리케이션 홈 페이지
예제 애플리케이션 홈 페이지
하지만 먼저 템플릿 엔진이 어떻게 초기화되는지 살펴 보겠습니다.

2.2 템플릿 엔진 생성 및 구성
필터 의 process (…) 메서드는 다음 줄을 포함합니다.

ITemplateEngine templateEngine = this.application.getTemplateEngine();
즉, GTVGApplication 클래스는 Thymeleaf 애플리케이션에서 가장 중요한 객체 중 하나 인 TemplateEngine인스턴스 ( ITemplateEngine인터페이스 구현)를 만들고 구성하는 작업을 담당합니다 .

우리의 org.thymeleaf.TemplateEngine목적은 다음과 같이 초기화된다 :

public class GTVGApplication {

    ...
    private final TemplateEngine templateEngine;
    ...


    public GTVGApplication(final ServletContext servletContext) {

        super();

        ServletContextTemplateResolver templateResolver =
                new ServletContextTemplateResolver(servletContext);

        // HTML is the default mode, but we set it anyway for better understanding of code
        templateResolver.setTemplateMode(TemplateMode.HTML);
        // This will convert "home" to "/WEB-INF/templates/home.html"
        templateResolver.setPrefix("/WEB-INF/templates/");
        templateResolver.setSuffix(".html");
        // Template cache TTL=1h. If not set, entries would be cached until expelled
        templateResolver.setCacheTTLMs(Long.valueOf(3600000L));

        // Cache is set to true by default. Set to false if you want templates to
        // be automatically updated when modified.
        templateResolver.setCacheable(true);

        this.templateEngine = new TemplateEngine();
        this.templateEngine.setTemplateResolver(templateResolver);

        ...

    }

}
TemplateEngine객체 를 구성하는 방법에는 여러 가지가 있지만 지금은이 몇 줄의 코드가 필요한 단계에 대해 충분히 알려줄 것입니다.

템플릿 리졸버
템플릿 리졸버부터 시작하겠습니다.

ServletContextTemplateResolver templateResolver =
new ServletContextTemplateResolver(servletContext);
템플릿 해석기는 org.thymeleaf.templateresolver.ITemplateResolver다음 과 같은 Thymeleaf API의 인터페이스를 구현하는 객체입니다 .

public interface ITemplateResolver {

    ...

    /*
     * Templates are resolved by their name (or content) and also (optionally) their
     * owner template in case we are trying to resolve a fragment for another template.
     * Will return null if template cannot be handled by this template resolver.
     */
    public TemplateResolution resolveTemplate(
            final IEngineConfiguration configuration,
            final String ownerTemplate, final String template,
            final Map<String, Object> templateResolutionAttributes);

}
이러한 객체는 템플릿에 액세스하는 방법을 결정하는 역할을하며,이 GTVG 애플리케이션에서는 모든 Java 웹 애플리케이션에 존재 하는 애플리케이션 전체 객체 인 Servlet Contextorg.thymeleaf.templateresolver.ServletContextTemplateResolver 에서 리소스로 템플릿 파일을 검색한다는 의미입니다 . , 웹 애플리케이션 루트의 리소스를 확인합니다.javax.servlet.ServletContext

그러나 이것이 템플릿 리졸버에 대해 말할 수있는 전부는 아닙니다. 일부 구성 매개 변수를 설정할 수 있기 때문입니다. 첫째, 템플릿 모드 :

templateResolver.setTemplateMode(TemplateMode.HTML);
HTML은의 기본 템플릿 모드 ServletContextTemplateResolver이지만 어쨌든 코드가 진행중인 작업을 명확하게 문서화 할 수 있도록 설정하는 것이 좋습니다.

templateResolver.setPrefix("/WEB-INF/templates/");
templateResolver.setSuffix(".html");
접두사 와 접미사 우리가 사용하는 실제 자원 이름을 얻기 위해 엔진에 전달됩니다 템플릿 이름을 수정합니다.

이 구성을 사용하면 템플릿 이름 "제품 / 목록" 은 다음과 같습니다.

servletContext.getResourceAsStream("/WEB-INF/templates/product/list.html")
필요에 따라 구문 분석 된 템플릿이 캐시에있을 수있는 시간은 cacheTTLMs 속성 을 통해 템플릿 확인자에서 구성 됩니다.

templateResolver.setCacheTTLMs(3600000L);
최대 캐시 크기에 도달하고 현재 캐시 된 항목 중 가장 오래된 항목 인 경우 TTL에 도달하기 전에 템플릿을 캐시에서 계속 추방 할 수 있습니다.

ICacheManager인터페이스 를 구현 하거나 StandardCacheManager기본 캐시를 관리하도록 개체를 수정하여 사용자가 캐시 동작 및 크기를 정의 할 수 있습니다 .

템플릿 리졸버에 대해 배울 것이 훨씬 더 많지만 지금은 템플릿 엔진 객체의 생성을 살펴 보겠습니다.

템플릿 엔진
템플릿 엔진 개체는 org.thymeleaf.ITemplateEngine인터페이스의 구현입니다 . 이러한 구현 중 하나는 Thymeleaf 코어에서 제공하며 org.thymeleaf.TemplateEngine여기에서 인스턴스를 만듭니다.

templateEngine = new TemplateEngine();
templateEngine.setTemplateResolver(templateResolver);
오히려 간단하지 않습니까? 우리에게 필요한 것은 인스턴스를 생성하고 템플릿 리졸버를 설정하는 것입니다.

템플릿 해석기는 나중에 다룰 다른 많은 매개 변수 (메시지 해석기, 캐시 크기 등)가 있지만 필요한 유일한 필수 매개 변수 TemplateEngine입니다. 지금은 이것이 우리에게 필요한 전부입니다.

이제 템플릿 엔진이 준비되었으며 Thymeleaf를 사용하여 페이지 생성을 시작할 수 있습니다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

3 텍스트 사용
3.1 다국어 환영
첫 번째 작업은 식료품 사이트의 홈페이지를 만드는 것입니다.

이 페이지의 첫 번째 버전은 제목과 환영 메시지 만 있으면 매우 간단합니다. 이것은 우리의 /WEB-INF/templates/home.html파일입니다.

<!DOCTYPE html>

<html xmlns:th="http://www.thymeleaf.org">

  <head>
    <title>Good Thymes Virtual Grocery</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" type="text/css" media="all" 
          href="../../css/gtvg.css" th:href="@{/css/gtvg.css}" />
  </head>

  <body>
  
    <p th:text="#{home.welcome}">Welcome to our grocery store!</p>
  
  </body>

</html>
가장 먼저 눈에 띄는 것은이 파일이 HTML이 아닌 태그를 포함하지 않기 때문에 모든 브라우저에서 올바르게 표시 될 수있는 HTML5라는 것입니다 (브라우저는 이해하지 못하는 모든 속성을 무시합니다 (예 :) th:text).

그러나 양식 에서 사용하는 이러한 비표준 속성 은 HTML5 사양에서 허용되지 않기 때문에이 템플릿이 실제로 유효한 HTML5 문서 th:\*가 아님을 알 수 있습니다. 사실, 우리는 태그에 HTML5와 전혀 다른 xmlns:th속성을 추가하고 있습니다 <html>.

<html xmlns:th="http://www.thymeleaf.org">
… 템플릿 처리에는 전혀 영향을 미치지 않지만 IDE가 모든 속성에 대한 네임 스페이스 정의가 없다는 불만을 제기하는 것을 방지 하는 주문으로 작동 th:*합니다.

그렇다면이 템플릿을 HTML5 유효 하게 만들고 싶다면 어떻게해야 할까요? 쉬움 : 세미콜론 ( ) 대신 data-속성 이름과 하이픈 ( -) 구분 기호에 접두사를 사용하여 Thymeleaf의 데이터 속성 구문으로 전환하십시오 :.

<!DOCTYPE html>

<html>

  <head>
    <title>Good Thymes Virtual Grocery</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" type="text/css" media="all" 
          href="../../css/gtvg.css" data-th-href="@{/css/gtvg.css}" />
  </head>

  <body>
  
    <p data-th-text="#{home.welcome}">Welcome to our grocery store!</p>
  
  </body>

</html>
사용자 정의 data-접두어 속성은 HTML5 사양에서 허용되므로 위의 코드를 사용하면 템플릿이 유효한 HTML5 문서가 됩니다.

두 표기법은 완전히 동일하고 상호 교환이 가능하지만 코드 샘플의 단순성과 간결함을 위해이 자습서에서는 네임 스페이스 표기법 ( th:*)을 사용합니다 . 또한 th:*표기법은 더 일반적이며 모든 Thymeleaf 템플릿 모드 ( XML, TEXT…) data-에서 허용되는 반면 표기법은 HTML모드 에서만 허용 됩니다.

th : ​​text 사용 및 텍스트 외부화
텍스트 외부화는 템플릿 파일에서 템플릿 코드 조각을 추출하여 별도의 파일 (일반적으로 .properties파일)에 보관 하고 다른 언어로 작성된 동등한 텍스트로 쉽게 대체 할 수 있도록합니다 (국제화 또는 간단히 i18n 이라고하는 프로세스 ). 외부화 된 텍스트 조각을 일반적으로 "메시지"라고 합니다.

메시지에는 항상 메시지를 식별하는 키가 있으며 Thymeleaf를 사용하면 다음 #{...}구문 을 사용하여 텍스트가 특정 메시지와 일치하도록 지정할 수 있습니다 .

<p th:text="#{home.welcome}">Welcome to our grocery store!</p>
여기서 볼 수있는 것은 실제로 Thymeleaf Standard Dialect의 두 가지 다른 기능입니다.

th:text값 식을 평가하고 호스트 태그의 몸과 결과를 설정하는 속성은, 효과적으로 "우리의 식료품 가게에 오신 것을 환영합니다!"를 교체 코드에서 볼 수있는 텍스트입니다.
#{home.welcome}에 지정된 표현 표준 표현 구문 의 텍스트가 의해 사용될 것을 지시하는 th:text속성은 메시지와되어야 home.welcome키 우리가 템플릿을 처리하고 로켈 중 대응.
자,이 외부화 된 텍스트는 어디에 있습니까?

Thymeleaf에서 외부화 된 텍스트의 위치는 완전히 구성 가능하며 org.thymeleaf.messageresolver.IMessageResolver사용되는 특정 구현에 따라 다릅니다 . 일반적으로 .properties파일을 기반으로 한 구현 이 사용되지만, 예를 들어 데이터베이스에서 메시지를 얻기 위해 원하는 경우 자체 구현을 만들 수 있습니다.

그러나 초기화 중에 템플릿 엔진에 대한 메시지 리졸버를 지정하지 않았으며 이는 애플리케이션이 에서 구현 한 표준 메시지 리졸버를 사용하고 있음을 의미합니다 org.thymeleaf.messageresolver.StandardMessageResolver.

표준 메시지 해석기는 /WEB-INF/templates/home.html다음과 같이 템플릿과 이름이 같은 동일한 폴더의 속성 파일에서 메시지를 찾을 것으로 예상합니다 .

/WEB-INF/templates/home_en.properties 영어 텍스트.
/WEB-INF/templates/home_es.properties 스페인어 텍스트 용.
/WEB-INF/templates/home_pt_BR.properties 포르투갈어 (브라질) 언어 텍스트 용.
/WEB-INF/templates/home.properties 기본 텍스트의 경우 (로케일이 일치하지 않는 경우).
home_es.properties파일을 살펴 보겠습니다 .

home.welcome=¡Bienvenido a nuestra tienda de comestibles!
이것이 Thymeleaf가 템플릿을 처리하는 데 필요한 전부입니다. 이제 홈 컨트롤러를 만들어 보겠습니다.

컨텍스트
템플릿을 처리하기 위해 이전에 본 인터페이스를 HomeController구현 하는 클래스 를 만듭니다 IGTVGController.

public class HomeController implements IGTVGController {

    public void process(
            final HttpServletRequest request, final HttpServletResponse response,
            final ServletContext servletContext, final ITemplateEngine templateEngine)
            throws Exception {

        WebContext ctx =
                new WebContext(request, response, servletContext, request.getLocale());

        templateEngine.process("home", ctx, response.getWriter());

    }

}
가장 먼저 보게되는 것은 컨텍스트 의 생성입니다 . Thymeleaf 컨텍스트는 org.thymeleaf.context.IContext인터페이스를 구현하는 객체 입니다. 컨텍스트는 변수 맵에서 템플릿 엔진 실행에 필요한 모든 데이터를 포함해야하며 외부화 된 메시지에 사용해야하는 로케일도 참조해야합니다.

public interface IContext {

    public Locale getLocale();
    public boolean containsVariable(final String name);
    public Set<String> getVariableNames();
    public Object getVariable(final String name);

}
org.thymeleaf.context.IWebContextServletAPI 기반 웹 애플리케이션 (예 : SpringMVC)에서 사용하기위한 이 인터페이스의 특수 확장이 있습니다 .

public interface IWebContext extends IContext {

    public HttpServletRequest getRequest();
    public HttpServletResponse getResponse();
    public HttpSession getSession();
    public ServletContext getServletContext();

}
Thymeleaf 코어 라이브러리는 다음 인터페이스 각각의 구현을 제공합니다.

org.thymeleaf.context.Context 구현 IContext
org.thymeleaf.context.WebContext 구현 IWebContext
컨트롤러 코드에서 볼 수 있듯이 WebContext우리가 사용하는 코드 입니다. 실제로를 사용 ServletContextTemplateResolver하려면 컨텍스트 구현을 사용해야하므로 IWebContext.

WebContext ctx = new WebContext(request, response, servletContext, request.getLocale());
지정되지 않은 경우 시스템의 기본 로케일이 사용되기 때문에 4 개의 생성자 인수 중 3 개만 필요합니다 (실제 응용 프로그램에서는 이러한 일이 발생하지 않도록해야합니다).

WebContext템플릿 에서 요청 매개 변수와 요청, 세션 및 애플리케이션 속성을 가져 오는 데 사용할 수있는 몇 가지 특수 표현식이 있습니다 . 예를 들면 :

${x}xThymeleaf 컨텍스트 또는 요청 속성 으로 저장된 변수를 반환 합니다 .
${param.x}라는 요청 매개 변수 를 반환합니다 x(다중 값일 수 있음).
${session.x}라는 세션 속성 을 반환합니다 x.
${application.x}라는 서블릿 컨텍스트 속성 을 반환합니다 x.
템플릿 엔진 실행
컨텍스트 객체가 준비되었으므로 이제 컨텍스트를 사용하여 템플릿 (이름으로)을 처리하고 응답을 작성할 수 있도록 응답 작성자에게 전달하도록 템플릿 엔진에 지시 할 수 있습니다.

templateEngine.process("home", ctx, response.getWriter());
스페인어 로케일을 사용하여 결과를 보겠습니다.

<!DOCTYPE html>

<html>

  <head>
    <title>Good Thymes Virtual Grocery</title>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
    <link rel="stylesheet" type="text/css" media="all" href="/gtvg/css/gtvg.css" />
  </head>

  <body>
  
    <p>¡Bienvenido a nuestra tienda de comestibles!</p>

  </body>

</html>
3.2 텍스트 및 변수에 대한 추가 정보
이스케이프 처리되지 않은 텍스트
우리 홈페이지의 가장 간단한 버전이 이제 준비된 것 같지만 우리가 생각하지 않은 것이 있습니다. 이런 메시지가 있다면 어떨까요?

home.welcome=Welcome to our <b>fantastic</b> grocery store!
이전과 같이이 템플릿을 실행하면 다음을 얻을 수 있습니다.

<p>Welcome to our &lt;b&gt;fantastic&lt;/b&gt; grocery store!</p>
<b>태그가 이스케이프되어 브라우저에 표시 되기 때문에 예상했던 것과는 다릅니다.

이것은 th:text속성 의 기본 동작입니다 . Thymeleaf가 HTML 태그를 존중하고 이스케이프하지 않도록하려면 다른 속성을 사용해야합니다 th:utext( "이스케이프되지 않은 텍스트"의 경우).

<p th:utext="#{home.welcome}">Welcome to our grocery store!</p>
이렇게하면 원하는대로 메시지가 출력됩니다.

<p>Welcome to our <b>fantastic</b> grocery store!</p>
변수 사용 및 표시
이제 홈페이지에 콘텐츠를 더 추가해 보겠습니다. 예를 들어 다음과 같이 환영 메시지 아래에 날짜를 표시 할 수 있습니다.

Welcome to our fantastic grocery store!

Today is: 12 july 2010
먼저 해당 날짜를 컨텍스트 변수로 추가하도록 컨트롤러를 수정해야합니다.

public void process(
final HttpServletRequest request, final HttpServletResponse response,
final ServletContext servletContext, final ITemplateEngine templateEngine)
throws Exception {

    SimpleDateFormat dateFormat = new SimpleDateFormat("dd MMMM yyyy");
    Calendar cal = Calendar.getInstance();

    WebContext ctx =
            new WebContext(request, response, servletContext, request.getLocale());
    ctx.setVariable("today", dateFormat.format(cal.getTime()));

    templateEngine.process("home", ctx, response.getWriter());

}
컨텍스트에 String호출 된 변수를 추가 today했으며 이제 템플릿에 표시 할 수 있습니다.

<body>

  <p th:utext="#{home.welcome}">Welcome to our grocery store!</p>

  <p>Today is: <span th:text="${today}">13 February 2011</span></p>
  
</body>
보시다시피, 우리는 여전히 th:text작업에 속성을 사용하고 있지만 (태그의 본문을 바꾸고 싶기 때문에 맞습니다) 이번에는 구문이 약간 다르고 #{...}표현식 값 대신에 ${...}하나. 이것은 변수 표현식 이며 이전에 논의한 컨텍스트 변수 맵에서 실행될 OGNL (Object-Graph Navigation Language) 이라는 언어로 된 표현식을 포함합니다 .

${today}표현은 단순히 "오늘이라는 변수를 얻을"의미하지만,이 표현이 더 복잡 할 수 있습니다 (같은 ${user.name}내용은 "사용자라는 변수를 얻고, 그 호출 getName()방법").

속성 값에는 많은 가능성이 있습니다 : 메시지, 변수 표현식… 그리고 훨씬 더. 다음 장에서는 이러한 모든 가능성이 무엇인지 보여줄 것입니다.
